<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Splarg Drop</title>
    <style>
        :root {
            --theme-color: #33ff00; /* Default Green */
            --bg-color: #050505;
        }

        /* RETRO STYLING */
        body {
            background-color: var(--bg-color);
            color: var(--theme-color);
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            text-shadow: 0 0 5px var(--theme-color);
            transition: color 0.3s, text-shadow 0.3s;
        }

        .game-wrapper {
            position: relative;
            display: none;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            display: block;
        }

        /* START SCREEN */
        .menu-screen {
            background: #000;
            border: 2px solid var(--theme-color);
            padding: 40px;
            max-width: 600px;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            transition: border-color 0.3s;
        }

        .menu-screen h1 {
            font-size: 3em;
            margin: 0 0 10px 0;
            letter-spacing: 5px;
            text-transform: uppercase;
        }

        .quote {
            font-style: italic;
            opacity: 0.8;
            font-size: 0.9em;
            margin-bottom: 30px;
            border-left: 2px solid var(--theme-color);
            padding-left: 15px;
            text-align: left;
            line-height: 1.4;
        }

        .attribution {
            display: block;
            margin-top: 10px;
            font-style: normal;
            font-weight: bold;
            text-align: right;
            font-size: 0.8em;
        }

        .config-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        label { font-size: 0.8em; margin-bottom: 5px; opacity: 0.8; }

        input[type="number"] {
            background: #000;
            border: 1px solid var(--theme-color);
            color: var(--theme-color);
            font-family: inherit;
            font-size: 1.2em;
            padding: 5px;
            width: 80px;
            text-align: center;
        }

        /* RETRO COLOR PICKER */
        .color-picker {
            display: flex;
            gap: 10px;
        }
        .swatch {
            width: 30px;
            height: 30px;
            border: 2px solid #333;
            cursor: pointer;
        }
        .swatch:hover { border-color: #fff; }
        .swatch.active { border-color: #fff; box-shadow: 0 0 10px #fff; }

        button {
            background: var(--theme-color);
            color: #000;
            border: none;
            font-family: inherit;
            font-size: 1.2em;
            font-weight: bold;
            padding: 10px 30px;
            cursor: pointer;
            margin-top: 10px;
            text-transform: uppercase;
            box-shadow: 0 0 10px var(--theme-color);
        }
        button:hover { opacity: 0.8; }
        
        button.quit-btn {
            background: transparent;
            border: 1px solid var(--theme-color);
            color: var(--theme-color);
            font-size: 1em;
            margin-top: 20px;
        }
        button.quit-btn:hover { background: rgba(255,255,255,0.1); }

        .hud {
            position: absolute;
            top: 0;
            right: -180px;
            width: 160px;
            text-align: left;
        }
        
        .hud-box {
            border: 1px solid var(--theme-color);
            padding: 10px;
            margin-bottom: 15px;
            background: #000;
        }
        
        .hud-title { font-size: 0.8em; opacity: 0.8; margin-bottom: 5px;}
        .hud-value { font-size: 1.4em; font-weight: bold; }

        /* In-Game Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            display: none;
            z-index: 10;
        }

        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        .game-wrapper.paused .overlay-pause { display: flex; }
        .game-wrapper.gameover .overlay-gameover { display: flex; }

    </style>
</head>
<body>

    <div class="menu-screen" id="startScreen">
        <h1>Splarg Drop</h1>
        
        <div class="quote">
            “You can drop a mouse down a thousand-yard mine shaft; and on arriving at the bottom, it gets a slight shock and walks away. A rat is killed, a man is broken, a horse splashes.”
            <span class="attribution">— J.B.S. Haldane, "On Being the Right Size"</span>
        </div>

        <div class="config-row">
            <div class="input-group">
                <label>WIDTH</label>
                <input type="number" id="cfgWidth" value="12" min="4" max="50">
            </div>
            <div class="input-group">
                <label>HEIGHT</label>
                <input type="number" id="cfgHeight" value="20" min="10" max="100">
            </div>
             <div class="input-group">
                <label>SPEED (ms)</label>
                <input type="number" id="cfgSpeed" value="1000" step="100">
            </div>
        </div>

        <div class="config-row">
            <div class="input-group">
                <label>MONITOR TINT</label>
                <div class="color-picker" id="swatchContainer">
                    <div class="swatch active" style="background:#33ff00" onclick="updatePreviewColor('#33ff00', this)"></div>
                    <div class="swatch" style="background:#ffcc00" onclick="updatePreviewColor('#ffcc00', this)"></div>
                    <div class="swatch" style="background:#00ffff" onclick="updatePreviewColor('#00ffff', this)"></div>
                    <div class="swatch" style="background:#ff00ff" onclick="updatePreviewColor('#ff00ff', this)"></div>
                    <div class="swatch" style="background:#ffffff" onclick="updatePreviewColor('#ffffff', this)"></div>
                </div>
            </div>
        </div>

        <button onclick="initGame()">Initialize Splarg</button>
        <p style="font-size:0.7em; margin-top:20px;" id="menuGpStatus">GAMEPAD: WAITING...</p>
    </div>

    <div class="game-wrapper" id="gameWrapper">
        <canvas id="splargCanvas" width="400" height="600"></canvas>

        <div class="hud" id="hud">
            <div class="hud-box">
                <div class="hud-title">SCORE</div>
                <div class="hud-value" id="scoreDisplay">0</div>
            </div>
            <div class="hud-box">
                <div class="hud-title">SPEED</div>
                <div class="hud-value" id="speedDisplay">1.0s</div>
            </div>
             <div class="hud-box">
                <div class="hud-title">SYSTEM</div>
                <div style="font-size: 0.7em;" id="gamepadStatus">NO CONTROLLER</div>
            </div>
        </div>

        <div class="overlay overlay-pause">
            <h2>SYSTEM PAUSED</h2>
            <p class="blink">PRESS START TO RESUME</p>
            <br>
            <p style="font-size:0.8em">DPAD LEFT/RIGHT: ADJUST SPEED</p>
            
            <button class="quit-btn" onclick="quitToMenu()">QUIT TO MENU</button>
        </div>

        <div class="overlay overlay-gameover">
            <h1 style="color: #fff" id="gameOverTitle">FAILURE</h1>
            <p>FINAL SCORE: <span id="finalScore">0</span></p>
            <br>
            <button onclick="restartGame()">RESTART</button>
            <button class="quit-btn" onclick="quitToMenu()">QUIT TO MENU</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('splargCanvas');
        const context = canvas.getContext('2d');
        const wrapper = document.getElementById('gameWrapper');
        const startScreen = document.getElementById('startScreen');

        // UI Elements
        const scoreElement = document.getElementById('scoreDisplay');
        const speedElement = document.getElementById('speedDisplay');
        const finalScoreElement = document.getElementById('finalScore');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gpStatus = document.getElementById('gamepadStatus');
        const menuGpStatus = document.getElementById('menuGpStatus');

        // Game State
        let arena;
        let player = { pos: {x: 0, y: 0}, matrix: null, score: 0 };
        let dropInterval = 1000;
        let dropCounter = 0;
        let lastTime = 0;
        let score = 0;
        let isPaused = false;
        let isGameOver = false;
        let isRunning = false; // "In Game" flag
        let isInMenu = true;   // "In Menu" flag
        
        // Visuals
        let themeColor = '#33ff00';
        let BOARD_W = 12;
        let BOARD_H = 20;
        let BLOCK_SIZE = 20;

        // --- Configuration & Styling ---

        function updatePreviewColor(color, el) {
            themeColor = color;
            document.documentElement.style.setProperty('--theme-color', color);
            
            // Update active swatch UI
            document.querySelectorAll('.swatch').forEach(s => s.classList.remove('active'));
            if(el) el.classList.add('active');
        }

        function initGame() {
            // Read Inputs
            const wInput = parseInt(document.getElementById('cfgWidth').value);
            const hInput = parseInt(document.getElementById('cfgHeight').value);
            const sInput = parseInt(document.getElementById('cfgSpeed').value);

            // Apply Settings
            BOARD_W = wInput > 3 ? wInput : 12;
            BOARD_H = hInput > 5 ? hInput : 20;
            dropInterval = sInput > 0 ? sInput : 1000;

            // Calculate Scale for Canvas
            const scaleX = (canvas.width - 40) / BOARD_W; 
            const scaleY = (canvas.height - 40) / BOARD_H;
            BLOCK_SIZE = Math.min(scaleX, scaleY);
            
            // Center the board
            const totalBoardWidth = BOARD_W * BLOCK_SIZE;
            const totalBoardHeight = BOARD_H * BLOCK_SIZE;
            const offsetX = (canvas.width - totalBoardWidth) / 2;
            const offsetY = (canvas.height - totalBoardHeight) / 2;

            context.setTransform(1, 0, 0, 1, 0, 0); 
            context.translate(offsetX, offsetY);
            context.scale(BLOCK_SIZE, BLOCK_SIZE);

            // Switch Screens
            isInMenu = false;
            startScreen.style.display = 'none';
            wrapper.style.display = 'flex'; 
            
            // Prevent immediate input bleed from menu
            buttonCooldowns.pause = Date.now() + 500;
            buttonCooldowns.confirm = Date.now() + 500;
            
            // Start Loop
            arena = createMatrix(BOARD_W, BOARD_H);
            playerReset();
            score = 0;
            updateScoreDisplay();
            updateSpeedDisplay();
            isGameOver = false;
            isPaused = false;
            isRunning = true;
            wrapper.classList.remove('gameover', 'paused');
            update();
        }

        function quitToMenu() {
            isRunning = false;
            isInMenu = true;
            wrapper.style.display = 'none';
            startScreen.style.display = 'block';
            wrapper.classList.remove('paused', 'gameover');
            
            // Restart menu input loop
            menuLoop();
        }

        // --- Core Logic ---

        function createPiece(type) {
            if (type === 'I') return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
            if (type === 'L') return [[0,1,0],[0,1,0],[0,1,1]];
            if (type === 'J') return [[0,1,0],[0,1,0],[1,1,0]];
            if (type === 'O') return [[1,1],[1,1]];
            if (type === 'Z') return [[1,1,0],[0,1,1],[0,0,0]];
            if (type === 'S') return [[0,1,1],[1,1,0],[0,0,0]];
            if (type === 'T') return [[0,1,0],[1,1,1],[0,0,0]];
        }

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) matrix.push(new Array(w).fill(0));
            return matrix;
        }

        function drawMatrix(matrix, offset) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // Main Block Color
                        context.fillStyle = themeColor; 
                        context.fillRect(x + offset.x, y + offset.y, 1, 1);
                        
                        // "Hollow" Center
                        context.fillStyle = '#000000'; 
                        context.fillRect(x + offset.x + 0.1, y + offset.y + 0.1, 0.8, 0.8);
                        
                        // Inner Dot
                        context.fillStyle = themeColor;
                        context.fillRect(x + offset.x + 0.3, y + offset.y + 0.3, 0.4, 0.4);
                    }
                });
            });
        }

        function draw() {
            // Clear entire canvas (untransformed)
            context.save();
            context.setTransform(1,0,0,1,0,0);
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.restore();

            // Draw Single Clean Wall (Board Border)
            context.strokeStyle = themeColor;
            context.lineWidth = 0.1; // 10% of a block width
            context.strokeRect(0, 0, BOARD_W, BOARD_H);
            
            drawMatrix(arena, {x: 0, y: 0});
            drawMatrix(player.matrix, player.pos);
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
                });
            });
        }

        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            if (dir > 0) matrix.forEach(row => row.reverse());
            else matrix.reverse();
        }

        function collide(arena, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        function arenaSweep() {
            let rowCount = 0;
            outer: for (let y = arena.length - 1; y > 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) continue outer;
                }
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
                ++y;
                rowCount++;
            }
            if (rowCount > 0) {
                const lineScores = [0, 40, 100, 300, 1200];
                score += lineScores[rowCount];
                updateScoreDisplay();
            }
        }

        function playerReset() {
            const pieces = 'ILJOTSZ';
            player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);
            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            
            if (collide(arena, player)) {
                triggerGameOver();
            }
        }

        function playerDrop() {
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                playerReset();
                arenaSweep();
            }
            dropCounter = 0;
        }

        function playerHardDrop() {
            while (!collide(arena, player)) {
                player.pos.y++;
            }
            player.pos.y--; 
            merge(arena, player);
            playerReset();
            arenaSweep();
            dropCounter = 0;
        }

        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(arena, player)) {
                player.pos.x -= dir;
            }
        }

        function playerRotate(dir) {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix, dir);
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -dir);
                    player.pos.x = pos;
                    return;
                }
            }
        }
        
        // --- UI Updates ---
        
        function updateScoreDisplay() { scoreElement.innerText = score; }
        
        function updateSpeedDisplay() {
            speedElement.innerText = (dropInterval / 1000).toFixed(1) + 's';
        }
        
        function changeSpeed(delta) {
            dropInterval += delta;
            if (dropInterval < 100) dropInterval = 100;
            if (dropInterval > 2000) dropInterval = 2000;
            updateSpeedDisplay();
        }

        function triggerGameOver() {
            isGameOver = true;
            wrapper.classList.add('gameover');
            finalScoreElement.innerText = score;

            // DYNAMIC GAME OVER TITLE
            if (score < 500) {
                gameOverTitle.innerText = "MOUSE SHOCKED";
            } else if (score < 2000) {
                gameOverTitle.innerText = "RAT KILLED";
            } else if (score < 5000) {
                gameOverTitle.innerText = "MAN BROKEN";
            } else {
                gameOverTitle.innerText = "HORSE SPLASHED";
            }
        }

        function restartGame() {
            arena.forEach(row => row.fill(0));
            score = 0;
            isGameOver = false;
            isPaused = false;
            wrapper.classList.remove('gameover', 'paused');
            updateScoreDisplay();
            playerReset();
        }

        function togglePause() {
            if (isGameOver) return;
            isPaused = !isPaused;
            if (isPaused) wrapper.classList.add('paused');
            else wrapper.classList.remove('paused');
        }

        // --- Controls ---
        let buttonCooldowns = { left: 0, right: 0, down: 0, up: 0, rotate: 0, pause: 0, confirm: 0 };

        window.addEventListener("gamepadconnected", (e) => {
            const msg = "CONTROLLER ACTIVE";
            gpStatus.innerText = msg;
            menuGpStatus.innerText = msg + " (PRESS START/A)";
            menuGpStatus.style.opacity = 1;
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            const msg = "NO CONTROLLER";
            gpStatus.innerText = msg;
            menuGpStatus.innerText = msg;
        });

        // MENU LOOP (Runs when in Start Screen)
        function menuLoop() {
            if (!isInMenu) return; // Stop if game started

            const gp = navigator.getGamepads()[0];
            if (gp) {
                // Button 9 is usually START, Button 0 is usually A/Cross
                if (gp.buttons[9].pressed || gp.buttons[0].pressed) {
                    initGame();
                    return;
                }
            }
            requestAnimationFrame(menuLoop);
        }

        // GAME LOOP (Runs when playing)
        function updateGamepad() {
            const gp = navigator.getGamepads()[0];
            if (!gp) return;
            const now = Date.now();
            const axisX = gp.axes[0];
            const axisY = gp.axes[1];
            
            if (gp.buttons[9].pressed && now > buttonCooldowns.pause) {
                togglePause();
                buttonCooldowns.pause = now + 300;
            }

            if (isGameOver) {
                // Restart
                if ((gp.buttons[0].pressed || gp.buttons[9].pressed) && now > buttonCooldowns.confirm) {
                    restartGame();
                    buttonCooldowns.confirm = now + 500;
                }
                // Quit
                if (gp.buttons[8].pressed && now > buttonCooldowns.confirm) {
                    quitToMenu();
                    buttonCooldowns.confirm = now + 500;
                }
                return;
            }

            if (isPaused) {
                if (gp.buttons[8].pressed && now > buttonCooldowns.confirm) {
                    quitToMenu();
                    buttonCooldowns.confirm = now + 500;
                }
                if ((gp.buttons[14].pressed || axisX < -0.5) && now > buttonCooldowns.left) {
                    changeSpeed(100); buttonCooldowns.left = now + 200;
                }
                if ((gp.buttons[15].pressed || axisX > 0.5) && now > buttonCooldowns.right) {
                    changeSpeed(-100); buttonCooldowns.right = now + 200;
                }
                return;
            }

            if ((gp.buttons[14].pressed || axisX < -0.5) && now > buttonCooldowns.left) {
                playerMove(-1); buttonCooldowns.left = now + 100;
            }
            if ((gp.buttons[15].pressed || axisX > 0.5) && now > buttonCooldowns.right) {
                playerMove(1); buttonCooldowns.right = now + 100;
            }
            if ((gp.buttons[13].pressed || axisY > 0.5) && now > buttonCooldowns.down) {
                playerDrop(); buttonCooldowns.down = now + 50;
            }
            if ((gp.buttons[12].pressed) && now > buttonCooldowns.up) {
                playerHardDrop(); buttonCooldowns.up = now + 300;
            }
            if ((gp.buttons[0].pressed || gp.buttons[1].pressed || gp.buttons[2].pressed || gp.buttons[3].pressed) && now > buttonCooldowns.rotate) {
                playerRotate(1); buttonCooldowns.rotate = now + 200;
            }
        }

        function update(time = 0) {
            if(!isRunning) return;
            const deltaTime = time - lastTime;
            lastTime = time;
            updateGamepad();
            if (!isPaused && !isGameOver) {
                dropCounter += deltaTime;
                if (dropCounter > dropInterval) playerDrop();
            }
            draw();
            requestAnimationFrame(update);
        }

        document.addEventListener('keydown', event => {
            if(!isRunning) return;
            if (isGameOver) { if (event.keyCode === 13) restartGame(); return; }
            if (event.keyCode === 27) togglePause();
            if (isPaused) {
                if (event.keyCode === 37) changeSpeed(100);
                if (event.keyCode === 39) changeSpeed(-100);
                return;
            }
            if (event.keyCode === 37) playerMove(-1);
            else if (event.keyCode === 39) playerMove(1);
            else if (event.keyCode === 40) playerDrop();
            else if (event.keyCode === 38) playerHardDrop();
            else if (event.keyCode === 81 || event.keyCode === 87) playerRotate(1);
        });

        // Start input polling immediately
        menuLoop();
    </script>
</body>
</html>
